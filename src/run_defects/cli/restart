# %%
from __future__ import annotations

import json
import logging
from pathlib import Path

import click
from fireworks import LaunchPad
from monty.json import MontyDecoder, jsanitize
from pymatgen.io.vasp.inputs import Incar, Poscar
from icecream import ic

LPAD = LaunchPad.auto_load()
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


def _get_fw_id_by_state(query=None, state="FIZZLED"):
    """Find the fizzed relaxation jobs.

    The atomate2 created fireworks for long running relaxation jobs should be simple.
    Basically `spec._tasks.0` should be the relaxation job.

        Args:
                query: query to use.  The basic query is already included.

        Returns:
                list: list of fizzled fireworks ids
    """
    fw_query = {
        "spec._tasks.0.job.function.@callable": "BaseVaspMaker.make",
        "state": state,
        "$or": [
            {"spec._tasks.0.job.function_args.0.@class": "Structure"},
            {"spec._tasks.0.job.function_args.0.@class": "OutputReference"},
            {"spec._tasks.0.job.function_args.0.@class": "Poscar"},
        ],
    }
    fw_query.update(query or {})
    return LPAD.get_fw_ids(query=fw_query)


def _get_last_launch_dir(fw_dict):
    """Get the last launch directory for a fizzled job.

    Args:
            fw_id: fireworks id

    Returns:
            str: last launch directory
    """
    launches = fw_dict.get("launches", None)
    if launches is None:
        launches = fw_dict.get("archived_launches", None)
    if launches is None or len(launches) == 0:
        raise ValueError(f"Could not find launches for {fw_dict['fw_id']}")
    return launches[-1]["launch_dir"]


def _read_contcar(dir_name):
    """Read the CONTCAR currently in the directory.

    Args:
            dir_name: directory to read CONTCAR from

    Returns:
            Structure: structure from CONTCAR
    """
    # check for CONTCAR or CONTCAR.gz
    sub_dir = Path(dir_name)
    try:
        contcar_file = list(sub_dir.glob("CONTCAR*"))[0]
        contcar = Poscar.from_file(contcar_file)
    except Exception as e:
        raise RuntimeError(f"Cound not read CONTCAR from {dir_name}", "error", e)
    return contcar


def _read_incar(dir_name):
    """Read the INCAR currently in the directory.

    Args:
            dir_name: directory to read INCAR from

    Returns:
            incar_orig: original INCAR
            incar: current INCAR
    """
    try:
        incar_orig = Incar.from_file(Path(dir_name) / "INCAR.orig")
        incar = Incar.from_file(Path(dir_name) / "INCAR")
    except Exception as e:
        logger.error(e)
        return None, None
    return incar_orig, incar


def _recursive_update(orig, update_dict, path="_tasks"):
    """Update a dictionary recursively.

    Check if orig[key] is in update_dict, if it is then update it.
    Else, call _recursive_update(orig[key], update_dict)
    """
    if isinstance(orig, dict):
        for key, v in orig.items():
            if key in update_dict:
                if not isinstance(v, dict):
                    raise RuntimeError("Can only update dict.")
                for k_, v_ in update_dict[key].items():
                    yield f"{path}.{key}.{k_}", v_
            new_path = ".".join((path, key))
            if "archived_launches" not in path:
                yield from _recursive_update(orig[key], update_dict, path=new_path)

    elif isinstance(orig, list):
        for i, v in enumerate(orig):
            new_path = f"{path}.{i}"
            if "archived_launches" not in path:
                yield from _recursive_update(v, update_dict, path=new_path)


def _update_fizzled_firework(fw_id, update_dict, dry_run=True, check_fizzled=True):
    """Update a fizzled firework.

    Args:
        fw_id: fireworks id.
        update_dict: dictionary of updates.
        dry_run: dry run, default True, only print update dict.
    """
    # make sure the firework is fizzled
    fw_dict = LPAD.get_fw_dict_by_id(fw_id)
    if check_fizzled and fw_dict["state"] != "FIZZLED":
        raise RuntimeError("Firework must be fizzled.")

    updates_dict = dict(_recursive_update(fw_dict["spec"]["_tasks"], update_dict))
    if dry_run:
        ic(f"Would update {fw_id} with {updates_dict}")
        logger.debug(f"Would update {fw_id} with {updates_dict}")
    else:
        LPAD.update_spec([fw_id], updates_dict)


def update_incar_settings(fw_id, user_incar_setting, check_fizzled=True, dry_run=True):
    """Update a fizzled firework.

    Args:
        fw_id: fireworks id.
        user_incar_setting: dictionary of updates. Ex: {"EDIFFG": -0.005}
        dry_run: dry run, default True, only print update dict.
    """
    _update_fizzled_firework(
        fw_id=fw_id,
        update_dict={"user_incar_settings": user_incar_setting},
        dry_run=dry_run,
        check_fizzled=check_fizzled,
    )


def update_struct(fw_id, structure):
    """Update the spec structure for a fizzled job.

    Args:
        fw_id: fireworks id
        structure: structure to update to
    """
    update_dict = {
        "_tasks.0.job.function_args.0": jsanitize(structure.as_dict()),
    }
    LPAD.update_spec([fw_id], update_dict)


def _get_incar_diff(incar_old: Incar, incar_new: Incar):
    """Get the INCAR differences between two INCARs."""
    incar_diff = {}
    for k, v in incar_new.items():
        if incar_old.get(k, None) != v:
            incar_diff[k] = v
    return incar_diff


def get_charged_structure(fw_id):
    """Read the CONTCAR if available and decorate with the charge state.

    Args:
        fw_id: fireworks id
        use_defect_charge: use the defect charge state if available
    """
    fw_dict = LPAD.get_fw_dict_by_id(fw_id)
    dir_name = _get_last_launch_dir(fw_dict)
    if dir_name is None:
        raise RuntimeError(f"Could not find a launch directory for {fw_id}")
    else:
        logger.debug(f"Get the charged structure for {fw_id} from {dir_name}")
    contcar = _read_contcar(dir_name)
    structure = contcar.structure

    old_struct = fw_dict["spec"]["_tasks"][0]["job"]["function_args"][0]
    old_struct = MontyDecoder().process_decoded(
        fw_dict["spec"]["_tasks"][0]["job"]["function_args"][0]
    )
    structure._charge = old_struct._charge
    return structure


# # %%
# ready_ids = _get_fw_id_by_state(state="READY")
# for fw_id in ready_ids:
#     last_launch_dir = _get_last_launch_dir(LPAD.get_fw_dict_by_id(fw_id))
#     update_incar_settings(fw_id, {"LREAL": "Auto"}, check_fizzled=False, dry_run=True)

# #%%
# fw_id = _get_fizzled()[0]
# fw_dict = LPAD.get_fw_dict_by_id(fw_id)
# last_launch_dir = _get_last_launch_dir(fw_dict)
# contcar = _read_contcar(last_launch_dir)
# incar_orig, incar = _read_incar(last_launch_dir)
# incar_update_dict = _get_incar_diff(incar_orig, incar)

# # get the incar values that are different
# incar_diff = _get_incar_diff(incar_orig, incar)
# if swap_ibrion:
#     _swap_val = {1: 2, 2: 1}
#     incar_diff["IBRION"] = _swap_val[incar["IBRION"]]

# update_fizzled_incar_settings(fw_id, incar_diff, dry_run=False)
# cstruct = get_charged_structure(fw_id)
# update_struct(fw_id, cstruct)


# %%


# %%
@click.command()
@click.option("-q", "--query", default={})
@click.option("-d", "--dry-run", is_flag=True, show_default=True, default=False)
@click.option("-i", "--fw-id")
@click.option(
    "-b",
    "--ibrion-swap",
    is_flag=True,
    show_default=True,
    default=False,
    help="Swap IBRION value.",
)
def main(query, dry_run: bool, fw_id: int = None, ibrion_swap: bool = False):
    """Run the CLI."""
    q = json.loads(query)
    fizzled = [int(fw_id)] if fw_id is not None else _get_fw_id_by_state(q)
    for fw_id in fizzled:
        structure = get_charged_structure(fw_id)
        last_launch_dir = _get_last_launch_dir(LPAD.get_fw_dict_by_id(fw_id))
        incar_orig, incar = _read_incar(last_launch_dir)
        incar_update_dict = _get_incar_diff(incar_orig, incar)
        logger.info(f"INCAR Update: {incar_update_dict}")
        logger.info(f"Parsed Structure: {structure.formula}")

        if not dry_run:
            update_struct(fw_id, structure)
            if ibrion_swap:
                _swap_val = {1: 2, 2: 1, 3: 1}
                incar_update_dict["IBRION"] = _swap_val[incar["IBRION"]]
            update_incar_settings(fw_id, incar_update_dict, dry_run=False)
            LPAD.rerun_fw(fw_id)


# %%
if __name__ == "__main__":
    main()
